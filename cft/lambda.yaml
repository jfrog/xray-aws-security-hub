AWSTemplateFormatVersion: "2010-09-09"
Description: "Lambdas"

Parameters:
  LambdaAuthorizerName:
    Type: String
    Default: XrayAuthorizer
    Description: Lambda name for the Xray Security Hub Integration lambda. This string can include
      letters, numbers, hyphens (-), or underscores (_).
    AllowedPattern: ^[0-9a-zA-Z-_]*$
    ConstraintDescription:
      Xray Security Hub Integration lambda can include letters, numbers, hyphens (-), or underscores (_).
  LambdaRequestProcessorName:
    Type: String
    Default: XrayRequestProcessor
    Description: Lambda name for the Xray Security Hub Integration lambda. This string can include
      letters, numbers, hyphens (-), or underscores (_).
    AllowedPattern: ^[0-9a-zA-Z-_]*$
    ConstraintDescription:
      Xray Security Hub Integration lambda can include letters, numbers, hyphens (-), or underscores (_).
  LambdaMappingTransformerName:
    Type: String
    Default: XrayMappingTransformer
    Description: Lambda name for the Xray Security Hub Integration lambda. This string can include
      letters, numbers, hyphens (-), or underscores (_).
    AllowedPattern: ^[0-9a-zA-Z-_]*$
    ConstraintDescription:
      Xray Security Hub Integration lambda can include letters, numbers, hyphens (-), or underscores (_).

  SourceSQSForMappingTransformerArn:
    Type: String
    Description: Arn for the source SQS queue

#  SQSQueueStackName:
#    Description: Name of the SQS stack
#    Type: String
#    Default: SQSQueueStack



Resources:
  LambdaPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action: logs:CreateLogGroup
            Resource: !Join
              - ''
              - - 'arn:'
                - !Ref AWS::Partition
                - ':logs:'
                - !Ref AWS::Region
                - ':'
                - !Ref AWS::AccountId
                - ':*'
          - Effect: Allow
            Action:
              - logs:CreateLogGroup
              - logs:PutLogEvents
            Resource: !Join
              - ''
              - - 'arn:'
                - !Ref AWS::Partition
                - ':logs:'
                - !Ref AWS::Region
                - ':'
                - !Ref AWS::AccountId
                - ':log-group:/aws/lambda/'
                - !Ref LambdaAuthorizerName
                - ':*'
          - Effect: Allow
            Action:
              - logs:CreateLogGroup
              - logs:PutLogEvents
            Resource: !Join
              - ''
              - - 'arn:'
                - !Ref AWS::Partition
                - ':logs:'
                - !Ref AWS::Region
                - ':'
                - !Ref AWS::AccountId
                - ':log-group:/aws/lambda/'
                - !Ref LambdaRequestProcessorName
                - ':*'
          - Effect: Allow
            Action:
              - logs:CreateLogGroup
              - logs:PutLogEvents
            Resource: !Join
              - ''
              - - 'arn:'
                - !Ref AWS::Partition
                - ':logs:'
                - !Ref AWS::Region
                - ':'
                - !Ref AWS::AccountId
                - ':log-group:/aws/lambda/'
                - !Ref LambdaMappingTransformerName
                - ':*'
      PolicyName: SecurityHubXrayLambdaPolicy
      Roles:
        - !Ref LambdaRole
  # TODO: add different roles for the lambdas, only Transformer requires SQS access

  LambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Description: Security Hub Xray integration Lambda execution role
      Path: /
      Policies:
        - PolicyName: logs
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: arn:aws:logs:*:*:*
        - PolicyName: sqs
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - sqs:ReceiveMessage
                  - sqs:ReceiveMessage
                  - sqs:DeleteMessage
                  - sqs:GetQueueAttributes
                Resource: !Ref SourceSQSForMappingTransformerArn
#        - PolicyName: lambda
#          PolicyDocument:
#            Statement:
#              - Effect: Allow
#                Action:
#                  - lambda:InvokeFunction
#                Resource: !Sub ${WorkerLambda.Arn}

  LambdaAuthorizer:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          import re

          def lambda_handler(event, context):
              authToken = event['authorizationToken']
              print("Client token: " + authToken)
              print("Method ARN: " + event['methodArn'])

              '''
              Validate the incoming token and produce the principal user identifier
              associated with the token. This can be accomplished in a number of ways:

              1. Call out to the OAuth provider
              2. Decode a JWT token inline
              3. Lookup in a self-managed DB
              '''

              if authToken != 'foo':
                  raise Exception('Unauthorized')

              principalId = 'user'

              '''
              You can send a 401 Unauthorized response to the client by failing like so:

                raise Exception('Unauthorized')

              If the token is valid, a policy must be generated which will allow or deny
              access to the client. If access is denied, the client will receive a 403
              Access Denied response. If access is allowed, API Gateway will proceed with
              the backend integration configured on the method that was called.

              This function must generate a policy that is associated with the recognized
              principal user identifier. Depending on your use case, you might store
              policies in a DB, or generate them on the fly.

              Keep in mind, the policy is cached for 5 minutes by default (TTL is
              configurable in the authorizer) and will apply to subsequent calls to any
              method/resource in the RestApi made with the same token.

              The example policy below denies access to all resources in the RestApi.
              '''
              tmp = event['methodArn'].split(':')
              apiGatewayArnTmp = tmp[5].split('/')
              awsAccountId = tmp[4]

              policy = AuthPolicy(principalId, awsAccountId)
              policy.restApiId = apiGatewayArnTmp[0]
              policy.region = tmp[3]
              policy.stage = apiGatewayArnTmp[1]
              # policy.denyAllMethods()
              policy.allowAllMethods()
              # policy.allowMethod(HttpVerb.GET, '/*')

              # Finally, build the policy
              authResponse = policy.build()

              # new! -- add additional key-value pairs associated with the authenticated principal
              # these are made available by APIGW like so: $context.authorizer.<key>
              # additional context is cached
              context = {
                  'key': 'value',  # $context.authorizer.key -> value
                  'number': 1,
                  'bool': True
              }
              # context['arr'] = ['foo'] <- this is invalid, APIGW will not accept it
              # context['obj'] = {'foo':'bar'} <- also invalid

              authResponse['context'] = context

              return authResponse


          class HttpVerb:
              GET = 'GET'
              POST = 'POST'
              PUT = 'PUT'
              PATCH = 'PATCH'
              HEAD = 'HEAD'
              DELETE = 'DELETE'
              OPTIONS = 'OPTIONS'
              ALL = '*'


          class AuthPolicy(object):
              # The AWS account id the policy will be generated for. This is used to create the method ARNs.
              awsAccountId = ''
              # The principal used for the policy, this should be a unique identifier for the end user.
              principalId = ''
              # The policy version used for the evaluation. This should always be '2012-10-17'
              version = '2012-10-17'
              # The regular expression used to validate resource paths for the policy
              pathRegex = '^[/.a-zA-Z0-9-\*]+$'

              '''Internal lists of allowed and denied methods.

              These are lists of objects and each object has 2 properties: A resource
              ARN and a nullable conditions statement. The build method processes these
              lists and generates the approriate statements for the final policy.
              '''
              allowMethods = []
              denyMethods = []

              """Replace the placeholder value with a default API Gateway API id to be used in the policy.
              Beware of using '*' since it will not simply mean any API Gateway API id, because stars will greedily expand over '/' or other separators.
              See https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_resource.html for more details."""
              restApiId = "<<restApiId>>"

              """Replace the placeholder value with a default region to be used in the policy.
              Beware of using '*' since it will not simply mean any region, because stars will greedily expand over '/' or other separators.
              See https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_resource.html for more details."""
              region = "<<region>>"

              """Replace the placeholder value with a default stage to be used in the policy.
              Beware of using '*' since it will not simply mean any stage, because stars will greedily expand over '/' or other separators.
              See https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_resource.html for more details."""
              stage = "<<stage>>"

              def __init__(self, principal, awsAccountId):
                  self.awsAccountId = awsAccountId
                  self.principalId = principal
                  self.allowMethods = []
                  self.denyMethods = []

              def _addMethod(self, effect, verb, resource, conditions):
                  '''Adds a method to the internal lists of allowed or denied methods. Each object in
                  the internal list contains a resource ARN and a condition statement. The condition
                  statement can be null.'''
                  if verb != '*' and not hasattr(HttpVerb, verb):
                      raise NameError('Invalid HTTP verb ' + verb + '. Allowed verbs in HttpVerb class')
                  resourcePattern = re.compile(self.pathRegex)
                  if not resourcePattern.match(resource):
                      raise NameError('Invalid resource path: ' + resource + '. Path should match ' + self.pathRegex)

                  if resource[:1] == '/':
                      resource = resource[1:]

                  resourceArn = 'arn:aws:execute-api:{}:{}:{}/{}/{}/{}'.format(self.region, self.awsAccountId, self.restApiId, self.stage, verb, resource)

                  if effect.lower() == 'allow':
                      self.allowMethods.append({
                          'resourceArn': resourceArn,
                          'conditions': conditions
                      })
                  elif effect.lower() == 'deny':
                      self.denyMethods.append({
                          'resourceArn': resourceArn,
                          'conditions': conditions
                      })

              def _getEmptyStatement(self, effect):
                  '''Returns an empty statement object prepopulated with the correct action and the
                  desired effect.'''
                  statement = {
                      'Action': 'execute-api:Invoke',
                      'Effect': effect[:1].upper() + effect[1:].lower(),
                      'Resource': []
                  }

                  return statement

              def _getStatementForEffect(self, effect, methods):
                  '''This function loops over an array of objects containing a resourceArn and
                  conditions statement and generates the array of statements for the policy.'''
                  statements = []

                  if len(methods) > 0:
                      statement = self._getEmptyStatement(effect)

                      for curMethod in methods:
                          if curMethod['conditions'] is None or len(curMethod['conditions']) == 0:
                              statement['Resource'].append(curMethod['resourceArn'])
                          else:
                              conditionalStatement = self._getEmptyStatement(effect)
                              conditionalStatement['Resource'].append(curMethod['resourceArn'])
                              conditionalStatement['Condition'] = curMethod['conditions']
                              statements.append(conditionalStatement)

                      if statement['Resource']:
                          statements.append(statement)

                  return statements

              def allowAllMethods(self):
                  '''Adds a '*' allow to the policy to authorize access to all methods of an API'''
                  self._addMethod('Allow', HttpVerb.ALL, '*', [])

              def denyAllMethods(self):
                  '''Adds a '*' allow to the policy to deny access to all methods of an API'''
                  self._addMethod('Deny', HttpVerb.ALL, '*', [])

              def allowMethod(self, verb, resource):
                  '''Adds an API Gateway method (Http verb + Resource path) to the list of allowed
                  methods for the policy'''
                  self._addMethod('Allow', verb, resource, [])

              def denyMethod(self, verb, resource):
                  '''Adds an API Gateway method (Http verb + Resource path) to the list of denied
                  methods for the policy'''
                  self._addMethod('Deny', verb, resource, [])

              def allowMethodWithConditions(self, verb, resource, conditions):
                  '''Adds an API Gateway method (Http verb + Resource path) to the list of allowed
                  methods and includes a condition for the policy statement. More on AWS policy
                  conditions here: http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements.html#Condition'''
                  self._addMethod('Allow', verb, resource, conditions)

              def denyMethodWithConditions(self, verb, resource, conditions):
                  '''Adds an API Gateway method (Http verb + Resource path) to the list of denied
                  methods and includes a condition for the policy statement. More on AWS policy
                  conditions here: http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements.html#Condition'''
                  self._addMethod('Deny', verb, resource, conditions)

              def build(self):
                  '''Generates the policy document based on the internal lists of allowed and denied
                  conditions. This will generate a policy with two main statements for the effect:
                  one statement for Allow and one statement for Deny.
                  Methods that includes conditions will have their own statement in the policy.'''
                  if ((self.allowMethods is None or len(self.allowMethods) == 0) and
                          (self.denyMethods is None or len(self.denyMethods) == 0)):
                      raise NameError('No statements defined for the policy')

                  policy = {
                      'principalId': self.principalId,
                      'policyDocument': {
                          'Version': self.version,
                          'Statement': []
                      }
                  }

                  policy['policyDocument']['Statement'].extend(self._getStatementForEffect('Allow', self.allowMethods))
                  policy['policyDocument']['Statement'].extend(self._getStatementForEffect('Deny', self.denyMethods))

                  return policy
      Description: Dummy lambda
      FunctionName: !Ref LambdaAuthorizerName
      Handler: index.lambda_handler
      MemorySize: 256
      PackageType: Zip
      Role: !GetAtt LambdaRole.Arn
      Runtime: python3.8
      Timeout: 60

  LambdaRequestProcessor:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          class ServerError extends Error {
              constructor(message) {
                  super('Internal Server Error: ' + message);
              }
          }

          class ClientError extends Error {
              constructor(message) {
                  super('Invalid Request: ' + message);
              }
          }

          exports.handler = async (event, context) => {
              if (event.top_severity !== 'Low') {
                  throw new ServerError('Boom!');
              }

              if (event.watch_name !== 'Security') {
                  throw new ClientError('Doh!');
              }

              console.log(JSON.stringify(event));
              console.log(JSON.stringify(context));

              // TODO implement. Add API call to SQS to create a message with exact body payload
              return {
                  statusCode: 200,
                  body: JSON.stringify('Hello from Lambda!'),
              };
          };
      Description: Dummy lambda Request Processor
      FunctionName: !Ref LambdaRequestProcessorName
      Handler: index.handler
      MemorySize: 128
      PackageType: Zip
      Role: !GetAtt LambdaRole.Arn
      Runtime: nodejs16.x
      Timeout: 60
      Environment:
        Variables:
          TASK_QUEUE_URL: !Ref SourceSQSForMappingTransformerArn

  LambdaMappingTransformer:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          // Load the AWS SDK for Node.js
          var AWS = require('aws-sdk');
          // Set the region
          AWS.config.update({region: 'REGION'});
            
          // Create an SQS service object
          var sqs = new AWS.SQS({apiVersion: '2012-11-05'});
            
          var queueURL = "SQS_QUEUE_URL";
          
          var params = {
            AttributeNames: [
              "SentTimestamp"
            ],
            MaxNumberOfMessages: 10,
            MessageAttributeNames: [
              "All"
            ],
            QueueUrl: queueURL,
            VisibilityTimeout: 20,
            WaitTimeSeconds: 0
          };
            
          sqs.receiveMessage(params, function(err, data) {
            if (err) {
              console.log("Receive Error", err);
            } else if (data.Messages) {
              var deleteParams = {
                QueueUrl: queueURL,
                ReceiptHandle: data.Messages[0].ReceiptHandle
              };
              sqs.deleteMessage(deleteParams, function(err, data) {
                if (err) {
                  console.log("Delete Error", err);
                } else {
                  console.log("Message Deleted", data);
                }
              });
            }
          });
      Description: Dummy lambda Mapping Transformer
      FunctionName: !Ref LambdaMappingTransformerName
      Handler: index.handler
      MemorySize: 128
      PackageType: Zip
      Role: !GetAtt LambdaRole.Arn
      Runtime: nodejs16.x
      Timeout: 60
      Environment:
        Variables:
          SQS_QUEUE_URL: !Ref SourceSQSForMappingTransformerArn


  # Lambda will read events from the source SQS
  LambdaFunctionEventSourceMapping:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      # By default, an event source mapping batches records (10) together into a single payload that Lambda sends to your function
      # Match it to Security hub limit batch limit
      BatchSize: 10
      Enabled: true
      EventSourceArn: !Ref SourceSQSForMappingTransformerArn
#      EventSourceArn:
#        Fn::ImportValue:
#          Fn::Sub: ${SQSQueueStackName}-XraySourceQueueARN
      FunctionName: !GetAtt LambdaMappingTransformer.Arn

Outputs:
  AuthorizerArn:
    Value: !GetAtt LambdaAuthorizer.Arn
  RequestProcessorArn:
    Value: !GetAtt LambdaRequestProcessor.Arn
  MappingTransformerArn:
    Value: !GetAtt LambdaMappingTransformer.Arn